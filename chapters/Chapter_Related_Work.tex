\chapter{Grundlagen}\label{ch:related_work}
%alles was man braucht um den Rest zu verstehen

\section{Ressourcen}
\subsection{Statische Ressourcen}
Statische Ressourcen sind Inhalte einer Website die für alle Nutzer gleich sind. Sie sind im Gegensatz zu dynamischen Inhalten nicht nutzerspezifisch und können daher gut über ein CDN verteilt werden. Insbesondere die so genannten Assets einer Internetseite sind meist statisch. Dies sind meist Javascript, CSS aber auch Bild Dateien. Auch Videos fallen häufig in diese Kategorie.

\subsection{Dynamisch generierte Ressourcen}

Dynamisch generierte Ressourcen werden zur Laufzeit der Website erzeugt und werden nicht im Vorfeld festgelegt. Dabei lässt sich zwischen Nutzergenerierten Inhalten und automatisch generierten Inhalten, z.b. Statistiken, unterscheiden.

Dynamische Inhalte sowohl Nutzer spezifisch sein, in diesem Fall werden jedem Nutzer bei selber abfrage andere Inhalte angezeigt.

\section{\cdn}
\todo{Detaillierter Komponenten Beschreiben plus Grafik. Siehe CDN Paper}
Unter einem \cdn, auch Content Delivery Network versteht man ein Netzwerk in dem sich Clients Inhalte von einer Reihe von Knoten laden. Ein \cdn stellt dem Nutzer Auslieferungs- und Speicherkapazitäten zur Verfügung. Dadurch kann die Last auf dem Ursprungsserver und die Latenz auf Seiten der Nutzer reduziert werden. Die reduzierten Ladezeiten werden unter anderem durch eine bessere geographische Nähe und damit geringerer Netzlaufzeiten erreicht. %TODO: gute definition finden

Es lassen sich drei Klassen von \cdns unterscheiden. Infrastruktur basierte CDN die auf einer geografisch verteilten Server Infrastruktur basieren, \pTp basierte \cdns bei denen die Inhalte direkt zwischen den Teilnehmern verteilt werden und Hybride \cdns die aus einer Kombination aus Server Infrastruktur und \pTp Verteilung beruhen.

%- Content Distribution Network
%- Servernetzwerk das inhalte lokal verteilt
%- reduzierung der physischen Entfernung
%- bereitstellung von auslieferkapazitäten
\subsection{Infrastruktur basierte \cdns}
Infrastruktur basierte \cdns bestehen aus einem Ursprungsservern, der von dem Bereitsteller der Inhalte kontrolliert wird, und einem Netzwerk aus replica Servern. Die replica Server übernehmen die Verteilung der Inhalte an die Clients. Sie fungieren als ein möglichst regionaler cache in dem Inhalte des Ursprungsservers gespiegelt werden. Ein Distributionssystem ist dafür verantwortlich die Inhalte auf den replicas zu aktualisieren und übernimmt das Routing bei einer Anfrage eines Clients. Unter Zuhilfenahme verschiedener Metriken versucht das Distributionssystem einen möglichst optimalen replica Server für den Client zu finden. Diese Metriken unterscheiden sich zwischen den Anbietern. Häufig werden jedoch geographische Entfernung, Latenzzeiten und die Übertragungsrate berücksichtigt. Um eine möglichst geringe Latenz zu erreichen sind Infrastruktur basierte \cdns häufig geografisch sehr verteilt und bestehen aus mehreren tausend replica Servern. So hat Akamai, einer der größten \cdn Anbietern, über 137000 Server in 87 Ländern. \cite{akamaiPeer} 

%-ein ursprungsserver
%- viele replicaserver
%- request routing system wählt optimalen replica server
%- ua. nach geographische Entfernung, Latenzzeit, Übertragungsrate
%137,000 servers in 87 countries%within over 1,150 Internet networks, \cite{akamaiPeer}

%https://de.wikipedia.org/wiki/Content_Delivery_Network
\subsection{\pTp basierte \cdns }



%
%
%test \cite{p2pBook2005}
% https://de.wikipedia.org/wiki/Peer-to-Peer#Typen_von_Peer-to-Peer-Systemen
%gegenmodell zu client server
%gleichbererchtigte teilnehmer eines rechnernetzwerkes
%overlays erklären??
%häufig aufgabenverteilung der peers
%unstrukturierte p2p:
%	keine peer objekt zuordnung
%	zentralisierte p2p netzwerke - server zur verwaltung
%	reine p2p netzwerke - keine verbindung zu unbekannten ips
%	hybride p2p n. mehere zentrale server die dynamisch zugeteilt werden
%	zenralisierte und reine p2p netzwerke 1.gen. 
%strukturierte p2p:
%	objektzuordnung vorhanden --> suche möglich
%	oft verteilte hashtabellen --> verteilter index

%Peers weisen eine hohe Heterogenität bezüglich der Bandbreite, Rechenkraft, Online-Zeit, … auf.
%Die Verfügbarkeit und Verbindungsqualität der Peers kann nicht vorausgesetzt werden („Churn“).
%Peers bieten Dienste und Ressourcen an und nehmen Dienste anderer Peers in Anspruch (Client-Server-Funktionalität).
%Dienste und Ressourcen können zwischen allen teilnehmenden Peers ausgetauscht werden.
%Peers bilden ein Overlay-Netzwerk und stellen damit zusätzliche Such-Funktionen zur Verfügung.
%Peers haben eine signifikante Autonomie (über die Ressourcenbereitstellung).
%Das P2P-System ist selbstorganisierend.
%Alle übrigen Systeme bleiben konstant intakt und nicht skaliert.
\subsection{Hybrid \cdns}
Hybrid \cdns kombinieren \pTp \cdns und Infrastruktur basierte \cdns. Bei hybriden \cdns wird zuerst versucht die Resource über das Peer Netzwerk zu laden. Ist dies nicht möglich wird auf ein Infrastruktur basiertes \cdn zurück gegriffen. Dadurch kann die Last auf dem \cdn verringert und durch die Kombination verschiedener \cdns eine bessere Ausfallsicherheit erreicht werden. Häufig kommt diese Art der \cdns zum Einsatz wenn Ressourcen für Websites mit einem \pTp Ansatz verteilt werden sollen. Da in diesem Kontext nicht alle Teilnehmer die technischen Vorraussetzungen mitbringen um an dem \pTp Netzwerk teilzunehmen ist eine entsprechende alternative Lösung nötig. Da die viele Websites bereits mit einem Infrastruktur basierten \cdn arbeiten ist es naheliegend dieses weiter zu verwenden.
\section{Verteilte Hashtabellen}

\section{\pTp Netzwerke}
Bei einem \pTp Netzwerk handelt es sich um eine Netzwerk Struktur bei der alle Teilnehmer gleichberechtigt sind. Sie bildet damit das gegen Konzept zur klassischen Client-Server Struktur, bei der einer oder mehrere Server einen Dienst anbieten der von Clients genutzt werden kann. In einem \pTp Netzwerk können die Teilnehmer sowohl Dienste anbieten als auch nutzen. Typische wenn auch nicht notwendige Charakteristika sind laut Steinmetz\cite{p2pBook2005}:

\begin{itemize}
  \item Heterogenität der Internetbandbreite der Teilnehmer
  \item Verfügbarkeit und Qualität der Verbindung zwischen Teilnehmern kann nicht vorausgesetzt werden
  \item Dienste werden von den Teilnehmern angeboten und genutzt
  \item Die Teilnehmer bilden ein Netz das auf ein bestehendes Netz aufgesetzt wird(Overlay Netzwerk) und stellen Suchfunktionen bereit
  \item Es besteht eine Autonomie der Teilnehmer bei der Bereitstellung von Ressourcen
  \item Das System ist selbstorganisiert
  \item Die restlichen Systeme müssen nicht skaliert werden und bleiben intakt
\end{itemize}
Sie lassen sich einteilen in zentralisierte, reine und hybride \pTp Netzwerke. Zentralisierte Netze haben zur Verwaltung einen Server der unter anderem die Verbindung der Teilnehmer übernimmt. Dadurch ist es möglich eine Verbindung aufzubauen ohne das die IP Adresse im Vorfeld bekannt ist. Reine \pTp Netzwerke haben keinen zentralen Verwaltungsserver. Die Verwaltung des Netzwerkes wird von den Teilnehmern selber übernommen. Das hat zur Folge das eine Verbindung nur möglich ist, wenn die IP Adresse des anderen Teilnehmers bekannt ist. 

Man unterscheidet zwischen unstrukturierten und strukturierten \pTp Netzwerken. 

\subsection{Unstrukturierte \pTp Netzwerke}
In unstrukturierten \pTp Netzwerken wird keine Zuordnung von Objekten zu Teilnehmern gespeichert. Um ein Objekt zu finden müssen alle Teilnehmer des Netzwerks gefragt werden.(Flooding) Dadurch steigt die Belastung des Netzwerks mit zunehmender Peer Anzahl.

\subsection{Strukturierte \pTp Netzwerke}
Strukturierte \pTp Netzwerke haben eine Zuordnung von Objekt und Teilnehmer. Es ist also möglich gezielt nach einem Objekt zu suchen. Dies wird häufig über verteilte Hash Tabellen, über die mit einem verteilten Index gesucht werden kann, realisiert.

\section{\webrtc - Web Real-Time Communication}

\webrtc ist ein offener Standard mit dem Echtzeit Kommunikation zwischen Browser und mobilen Anwendungen ermöglicht wird. Mit Hilfe von \webrtc ist es möglich eine \pTp Verbindung zwischen Browsern aufzubauen und Daten direkt zwischen den Clients auszutauschen ohne das externe Plugins erforderlich sind. Insbesondere der Austausch von Multimedia Inhalten wird ermöglicht. Neben der Unterstützung für Video und Audio Inhalten gibt es jedoch auch die Möglichkeit Daten auszutauschen. \webrtc wird vom W3C\cite{w3Webrtc} standarisiert und definiert eine Sammlung von APIs und Protokollen.


Aktuell wird \webrtc von Chrome, Firefox, Safari, Android und iOS unterstützt.\footnote{https://caniuse.com/\#feat=rtcpeerconnection} \webrtc implementiert drei APIs: MediaStream, RTCPeerConnection und RTCDataChannel die im folgenden genauer beschrieben werden.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/Webrtc_overview}
	\caption[A Figure Short-Title]{Überblick Server/Client Struktur Webrtc}
	\label{fig:webrtc_overview}
\end{figure}

% SSl erwähnen
% Server wird durch pTp gespart 
% TODO: SSL erklären???


%https://de.wikipedia.org/wiki/WebRTC
%https://www.w3.org/TR/webrtc/
%https://webrtc.org/

\subsection{Signaling}

Damit zwei \clients sich miteinander verbinden können müssen sie voneinander wissen und Informationen über Metadaten zum Verbindungsaufbau, wie z.B. IP-Adressen und Ports austauschen.

Das Signaling koordiniert die Kommunikation der Verbindungen zwischen Peers. Mit Hilfe des Signalings werden unter anderem die Metadaten ausgetauscht, die benötigt werden, um eine erfolgreiche WebRtc Verbindung aufzubauen. Dazu wird das SDP Protokoll verwendet. Unter anderem werden folgende Metdaten ausgetauscht:

\begin{itemize}
	\item Session Metadaten zum öffnen/schließen von Verbindungen
	\item Fehler Nachrichten
	\item Metadaten über die zu übertragenden Medien (z.b. Codecs)
	\item Schlüsseldaten für verschlüsselte Verbindungen
	\item Netzwerk Daten wie öffentliche IP Adressen und Ports
\end{itemize} 

Der Webrtc Standart legt keine für das Signaling zu verwendende Technologie und Protokolle fest um die Integration mit bestehenden Technologien zu verbessern und es dem Entwicklern zu ermöglichen das für den Anwendungsfall beste Protokoll zu verwenden. Allerdings legt er fest das eine bidirektionale Kommunikation zwischen den \clients notwendig ist.

%https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/#what-is-signaling

% For signaling: to enable the exchange of media and network metadata to bootstrap a peer connection.

\subsection{STUN Server - Simple Traversal of User Datagram Protocol [UDP] Through Network Address Translators}

Da die Anzahl von IPv4 Adressen begrenzt ist, verwenden die meisten Subnetze NATs. Das hat zur Folge das diese Clients nicht wissen wie über welche IP Adresse und welchen Port sie erreichbar sind. Daher ist der Einsatz von STUN Servern nötig um einen Verbindungsaufbau zu ermöglichen. Stun Server überprüfen eingehende Anfragen auf IP Adresse und Port und senden diese Informationen zurück an den Client, der somit in der Lage ist diese Information weiter zureichen und damit auch außerhalb seines lokalen Netzwerkes erreichbar ist. Das STUN-Protokoll ist im RFC 3489 \cite{rfcStun} definiert und ist nicht auf Webrtc beschränkt.


% TODO: evtl NATs erklären
%not enough IPv4 addresses
%→ most clients behind NATs, not reachable directly by IP address
%
%client behind NATs can’t know how they can get accessed from the internet
%→ using STUN server
%
%STUN servers check the IP and port of incoming request and send the information back

\subsection{TURN Server}

Verwaltete Netzwerke, wie die von Unternehmen, haben häufig Firewalls und Port blocking Systeme installiert um die Sicherheit des Netzwerks zu gewährleisten. Das kann dazu führen das \webrtc Verbindungen nicht aufgebaut oder Daten nicht über Webrtc Verbindungen übertragen werden können.

TURN Server bieten eine Fallback Lösung für diesen Fall. Sie haben eine öffentliche IP und sind über das Internet erreichbar. Im Fehlerfall kann der Datenverkehr über einen TURN Server geleitet werden, so das die Kommunikation nicht unterbrochen wird.

\subsection{SDP - Session Description Protocol}

\begin{itemize}
	\item Session Description Protocol (SDP, RFC 4566) 
	\item beschreibt Eigenschaften von Eigenschaften von Multimediadatenströmen
	\item verwaltet kommunikationssitzungen z.b. SIP(IP-telefonie)
	\item keine aushandlungsmechaniken sondern nur beschreibungen der Datenströme
	\item v=0
o=Alice 1234 1234 IN IP4 host.provider1.com
s=Video von 987654
c=IN IP4 host.provider2.com
t=0 0
m=audio 20000 RTP/AVP 97
a=rtpmap:97 iLBC/8000
a=fmtp:97 mode=30
m=video 20001 RTP/AVP 31
a=rtpmap:31 H261/90000
	\item daten aus eigener anwendung einfügen
	\item Felder beschreiben? zumindest die wichtigesten/verwendeten
\end{itemize}

\subsection{ICE}

\begin{itemize}
	\item Methode zur Überwindung von NAT
	\item Interactive Connectivity Establishment
	\item https://tools.ietf.org/html/rfc5245
	\item 
\end{itemize}
%setting: 2 peers, signaling server, STUN server
%each peer has a variety of candidate transport addresses (IP:port) 
%addresses from directly attached network (host candidate)
%translated transport (server reflexive) address
%ICE determine  which pairs of addresses work and which connection should be used
%try all possible pairs in smart order

\subsection{Webrtc API}
\begin{description}
\item[RTCPeerConnection]\hfill \\
Das RTCPeerConntection Interface repräsentiert eine Verbindung vom lokalen \client zu einem anderen \client. Ein RTCPeerConnection Objekt hält den momentanen Zustand der Verbindung ebenso wie Metadaten über den verbundenen Peer. Sie stellt Funktionen zum verwalten von Verbindungen bereit.

%\begin{itemize}
%	\item Repräsentiert verbindung zum peer
%	\item Code Beispiel
%\end{itemize}
% RTCPeerConnection is used to connect peers across the internet.


\item[RTCDataChannel]\hfill \\
\begin{itemize}
	\item Übertragung von raw data (Bitstreams)
	\item string, blob, arraybuffer, ArrayBufferView
	\item Übertragung mit Stream Control Transmission Protocol (SCTP)
	\item kurze erklärung SCTP
	\item 	Verbindungsorientiertes Netzwerkprotololl
	\item 	 RFC 4960
	\item 	Das zuständige Gremium bei der IETF ist die Arbeitsgruppe Signaling Transport, kurz SIGTRAN.xX
	\item 	Selbe stufe als Transportprokoll im stack wie TCP/UDP
	\item 	Konzept der Association: 
	\item 		mehrere Nachrichten-Datenströme in sich reihenfolgenerhaltend
	\item 		zwischen den Datenströmen muss die Reihenfolge nicht erhalten bleiben
	\item 	Multistreaming - Ein host mehere Ips
	\item 	Vier wege Handschake
	\item 		Hierbei speichert der Server bei einer Verbindungsanfrage (INIT-Paket) keine Zustandsinformationen, sondern schickt diese in Form eines Cookies (INIT-ACK-Paket) an den Client. Der Client muss dieses Cookie in seine Antwort (COOKIE-ECHO-Paket) einfügen und wird damit vom Server als zum Verbindungsaufbau berechtigt erkannt, was dieser ihm bestätigt (COOKIE-ACK-Paket)x
\end{itemize}
% Übertragung von allem was nicht audio oder video ist. zb. text von chats
% support für string, blob, arraybuffer, ArrayBufferView

% RTCDataChannel uses Stream Control Transmission Protocol (SCTP)
% RTCDataChannel can work in unreliable and unordered mode (analogous to User Datagram Protocol or UDP), reliable and ordered mode (analogous to Transmission Control Protocol or TCP) and partial reliable modes:
% Reliable and ordered mode guarantees the transmission of messages and also the order in which they are delivered. This takes extra overhead, thus potentially making this mode slower.
% Unreliable and unordered mode does not guarantee every message will get to the other side nor what order they get there. This removes the overhead, allowing this mode to work much faster.
% Partial reliable mode guarantees the transmission of message under a specific condition (such as a retransmit timeout or a maximum amount of retransmissions). The ordering of messages is also configurable.

% https://bloggeek.me/sctp-data-channel/


\item[MediaStream]\hfill \\
Die Mediastream Api, auch getUserMedia, ermöglicht es Echtzeit Daten wie audio oder Video aufzunehmen, anzuzeigen und an andere Clients weiter zu leiten und repräsentiert Medien Streams wie z.b. Audio oder Video Streams. Sie ermöglicht unter anderem den Zugriff auf Video Kameras und Mikrofone. Durch Sie ist es möglich auf die Hardwareunterstützung für Videos mittels open GL zuzugreifen. MediaStreams lassen sich mithilfe des src Attributes von HTML 5 video Elementen in das DOM einbinden. MediaStreams wurden von vom W3C in einem eigenen Standart definiert.\cite{w3MediaStream} 

\end{description}



\section{DataCache API}

Die DataCache Api ermöglicht es Netzwerk Requests zu cachen. Ursprünglich wurde die Api entwickelt um Service Workern die Möglichkeit zu geben einen Cache anzulegen und selbst zu verwalten. Dadurch ist es möglich mithilfe von Service Workern und der DataCache Api Websiten auch verfügbar zu machen wenn kein internet verfügbar ist. 

\begin{itemize}
	\item https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/cache-api
\end{itemize}

% https://www.w3.org/TR/DataCache/

\section{IndexedDB}

IndexedDB ist ein HTML 5 Feature um Daten im Browser zu speichern. Es wurde vom W3C standarisiert\cite{w3IndexedDB} und soll den veralteten Web Sql Standard ablösen. Im Gegensatz zu Web Sql hat die IndexedDB keine strukturierte Query Language und ihr liegt kein relationales Modell zu Grunde. Sie stellt einen Key-Value Store bereit der in der Lage ist auch große Datenmengen effektiv bereit zu stellen. Dabei ist der Datenzugriff auf die selbe Domain beschränkt. Die API ist überwiegend asynchron und basiert auf Promises.

\section{Service Worker}
Service Worker sind Skripte die im Browser als separate Prozesse im Hintergrund laufen, so genannte Web Worker. Sie stellen die Funktionalitäten eines programmierbaren Netzwerk Proxies bereit. Durch Service Worker ist es möglich die Anfragen einer Seite zu kontrollieren auf sie zu reagieren und in den Prozess einzugreifen.\cite{w3ServiceWorker} Service Worker haben keinen Zugriff auf das DOM. Sie könne mehrere Browser-Tabs und mit Hilfe des PostMessage Protokolls können Nachrichten zwischen Service Worker und Browser-Tab ausgetauscht werden. Da Service Worker Zugriff auf den DataCache und die IndexDB haben werden sie häufig verwendet um Internetseiten offline verfügbar zu machen. Bei der Registrierung eines Service Workers wird ein URL-Scope fest gelegt für den der Service Worker zuständig ist. Nur Anfragen die sich innerhalb des URL-Scopes des Service Workers befinden können von diesem bearbeitet werden.

%nur zugriff auf inhalte unterhalb der domain(nur gleiche domain)
%fetch event
%werden gestartet und gestoppt --> kein zuverlässiger globaler zustand
%having access to IndexDB
%https wird benötigt
\subsection{Lebenszyklus}
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/sw-lifecycle}
	\caption[A Figure Short-Title]{Lebenszyklus eines Service Workers\footnote{https://developers.google.com/web/fundamentals/primers/service-workers/}}
	\label{fig:swLifecycle}
\end{figure}
Nach dem ein Service Worker registriert wurde befindet er sich im Zustand der Installierung. Während der Installation werden häufig Inhalte in den Cache geladen. Wurde der Service Worker erfolgreich installiert wird er aktiviert. Ab diesem Punkt kann er Requests über das fetch event abfangen. Um Arbeitsspeicher zu sparen wird der Service Worker terminiert falls er keine Fetch oder Message events empfängt. Dies hat zu folge das ein Service Worker sich nicht auf den globalen Zustand verlassen kann, sondern statt dessen seinen Zustand auf die IndexedDb ausgelagert werden muss.



%register
%activate
%
%clients.claim

%https://developers.google.com/web/fundamentals/primers/service-workers/ (bild)
%https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API/Using_Service_Workers

\section{Websockets}


Websockets ist ein, auf TCP basierendes, Protokoll das bidirektionale Verbindungen zwischen Server und Webanwendung ermöglicht. Nachdem der Client eine Websocket Verbindung zum Server Aufgebaut hat ist es dem Server im Gegensatz zu HTTP möglich ohne vorherige Anfrage des Clients Daten an ihn zu senden. Zum initiieren einer Verbindung wird ein Handshake durchgeführt der vom Client angestoßen werden muss. Dazu wird wie bei HTTP der Port 80 verwendet. Der Server antwortet bei erfolgreichem Handshake mit dem HTTP Status code 101. Um eine Abwärtskompatibilität zu gewährleisten werden ähnliche Header wie bei HTTP verwendet.

Neben dem unverschlüsseltem URI-Schema ws definiert RFC6455\cite{rfcWebsockets} auch das verschlüsselte Schema wss. Da  sehr wenig Daten overhead bei der Kommunikation besteht eigenen sich Websockets insbesondere für Anwendungen die eine geringe Latenz benötigen. Websockets werden von allen modernen Browsern unterstützt.

%bidirektionale verbindung zwischen server und Webanwendung
%auf tcp basierendes protokoll
%very little data overhead needs to be exchanged to send messages. This means a low latency communication.
%WebSockets are great for real-time and long-lived communications.
%
%
%client öffnet verbindung danach kann der server ohne vorherige aktion des cients daten senden
%
% zwei neue URI-Schemata, ws: für unverschlüsselte, und wss: für verschlüsselte Verbindungen.
% 
% handshake zur initierung der verbindung
%  wie http über port 80
%  ähnlicher header --> abwärtskompatibel
%  server antwortet mit http status 101
%  
%WebSockets are supported by all modern browsers.


RFC6455\cite{rfcWebsockets}

\section{Distributed caches}
\begin{itemize}
	\item Hier Algorithmen erklären?
	\item auf hashes eingehen
	\item wie ein hash nur verteilt
\end{itemize}
\section{IP Adressen}
Eine IP Adresse ist ein eindeutiger Identifizier für Computer in einem Netzwerk. Jedem Computer in einem Netzwerk wird eine eindeutige IP Adresse zugewiesen über die der Computer adressierbar ist. Dadurch ist der Computer für andere erreichbar. Sie wird benötigt um ein routing vom Sender zum Empfänger zu ermöglichen. \cite{www}
\subsection{Aufbau von IP Adressen}
IPv4 wurde im Jahr 1981 durch das RFC 791\cite{rfc791} definiert und besteht aus einer 32 stelligen Binärzahl wodurch maximal 4.294.967.296 Adressen dargestellt werden können. Zur besseren Lesbarkeit werden IPv4 Adressen meist als vierer Blöcke in Dezimal geschrieben. IP Adressen bestehen aus einem Netz- und einem Hostanteil. Mit dem Netzanteil wird das Teilnetz indem sich das Gerät befindet beschrieben, während der Hostanteil das Gerät identifiziert. Durch eine Subnetzmaske wird festgelegt welcher Teil der IP-Adresse Host- und welcher Netzanteil ist. Alle Bits die in der Subnetzmaske 1 sind legen den Netzanteil fest - alle bits die 0 sind den Hostanteil.

\begin{table}
\begin{center}
\caption{Beispiel einer IP Adresse mit Subnetzmaske}
\begin{tabular}{|r|l|l|}
	\hline
	IP-Adresse & 145.574.322. & 5 \\ \hline
	Subnetzmaske & 255.255.255. & 0 \\ \hline
	& Netzanteil & Hostanteil \\
	\hline
\end{tabular}
\end{center}
\end{table}


Aufgrund der stark ansteigenden Zahl an Geräten die mit dem Internet verbunden sind ist der Adressbereich der IPv4 Adressen nicht mehr ausreichend. Entwickelte der ITFE 1998 einen neuen Standard. IPv6 verwendet 128 anstatt der 32 Bits zur Darstellung von IP Adressen. Dadurch ist es möglich 2$^3^2$ Geräte abzubilden. IPv6 wird meist als vier Oktette in hexadezimal dargestellt. Zur Unterscheidung von Host- und Netzanteil werden Präfixlängen angegeben.  

\subsection{Network Adress Translation(NAT)}
Mit Hilfe von NAT können mehrere Geräte über die selbe öffentliche IP-Adresse über das Internet verbunden werden. Dadurch ist es möglich trotz des begrenzten Adressraums von IPv4 mehr Geräte mit dem Internet zu verbinden. Dazu werden werden vom die IP-Adress header Felder der Datenpackete verändert. 

\section{Ruby on Rails}
Ruby on Rails ist ein in Ruby geschriebenes Opensource Webframework. Zentraler Ansatz der Entwicklung des Frameworks ist es, es Software Entwicklern einfacher zu machen Webanwendungen zu schreiben. Die Philosophie des Frameworks beinhaltet zwei Prinzipien:\footnote{https://guides.rubyonrails.org/}

\textbf{Don't Repeat Yourself(DRY):}
Jede Information und Funktionalität soll einen Repräsentation im System haben. Dadurch soll erreicht werden das die Software einfacher wartbar, über­sicht­licher und fehlerfreier sein.
 
\textbf{Convention over Configuration:}
Um die Entwicklung für den Programmierer zu erleichtern werden annahmen getroffen und Standard Einstellungen festgelegt. Diese lassen sich zwar durch die Entwickler ändern sind zu beginn jedes Projektes erst einmal gleich. So werden z.b. auch Vereinbarungen über die Benennung von Methoden und Klassen getroffen(Naming Conventions).

Ruby on Rails ist ein Model View Controller basiertes Framework. \todo{MVC Beschreiben?}

\section{Turbolinks}
Turbolinks\footnote{https://github.com/turbolinks/turbolinks} ist eine Javascript Bibliothek zur Beschleunigung der Navigation auf Internetseiten. Klick ein Nutzer auf einen Link wird der Seitenabruf unterbrochen und stattdessen mit Ajax geladen. Anschließend überprüft Turbolinks welche Teile der Seite sich verändert haben und rendert nur diese Elemente. Dadurch entsteht ein flüssigeres Nutzererlebnis da Teile der Seite bestehen bleiben und nicht ersetzt werden. Da nachgeladene Ressourcen die sich bei der Navigation nicht ändern nicht erneut geladen werden müssen beschleunigt sich die Ladezeit. Javascript scripts müssen nicht neu geladen werden sondern bleiben in ihrem vorigen Zustand bestehen da kein kompletter Pageload vorgenommen werden muss.

\section{Single Page Applications}

Unter Single Page Applications(SPA) versteht man Webanwendungen bei denen der Client aus einem einzigen HTML Dokument besteht. Inhalte werden meist dynamisch mit AJAX oder Websocket nachgeladen. Dadurch entsteht ein Nutzererlebnis das flüssiger erscheint da Seiten nicht bei Navigation komplett neu geladen werden müssen. Sie bieten sich für Anwendungen mit hoher Nutzerzahl an da der Aufwand der HTML renderings com Server auf den Client verlagert wird. Da das Backend zumeist nur Daten ausliefert wird die Entwicklung nativer Clients für Mobilgeräte vereinfacht da zumeist das Backend wiederverwendet werden kann.
\todo{Woher quellen nehmen??? online??}

\section{Redis}
Bei Redis handelt es sich um einen In-Memory Datenstruktur Speicher der als LRU cache, Datenbank oder Message Broker verwendet werden kann.\footnote{https://redis.io/} Redis ist ein Opensource Projekt und  wird von Redis Labs gesponsert. Jede gespeicherte Datenstruktur ist über einen Key abrufbar.

Unter anderem unterstützt Redis folgende Datentypen:
Set:
Bei Sets handelt es sich um Mengen die Strings beinhalten können. Wobei jeder String nur einmal pro Set vorkommt. Hinzufügen von Element, Löschen von Elementen und das prüfen ob ein Element in einem Set vorhanden ist passieren in konstanter Zeit. (O(1))

Strings:
Redis Strings sind binary safe, das heißt sie können jegliche Daten, z.B. auch Bilddaten, enthalten. Strings können auch als atomare Counter verwendet werden. Dazu stellt Redis Kommandos bereit zum erhöhen oder subtrahieren von Strings.

List:
Listen enthalten eine geordnete Liste von Strings, in der Reihenfolge in der sie hinzugefügt wurden. Elemente können sowohl vorne als auch hinten in die Liste eingefügt werden
